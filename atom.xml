<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空心话</title>
  
  <subtitle>闲来无事</subtitle>
  <link href="/lipapa.github.io/atom.xml" rel="self"/>
  
  <link href="https://lipapasma.github.io/lipapa.github.io/"/>
  <updated>2018-07-29T16:40:17.913Z</updated>
  <id>https://lipapasma.github.io/lipapa.github.io/</id>
  
  <author>
    <name>Lipapa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CommonJs规范</title>
    <link href="https://lipapasma.github.io/lipapa.github.io/2018/07/30/COMMONjs%E8%A7%84%E8%8C%83/"/>
    <id>https://lipapasma.github.io/lipapa.github.io/2018/07/30/COMMONjs规范/</id>
    <published>2018-07-29T16:20:45.000Z</published>
    <updated>2018-07-29T16:40:17.913Z</updated>
    
    <content type="html"><![CDATA[<p><strong>commonJS 规范</strong></p><ol><li>什么是commonjs 规范? <br><br>commonjs 是为了实现Jacascript的模块化,而制定的一套规范</li></ol><ol start="2"><li>为什么Jacascript 需要模块化? <br><br>简化代码的结构,提升代码的效率,就是代码复用<br>可以让一个js 文件内的<em>方法</em> <em>函数</em> 单独来回引用!</li><li>优缺点:<br>可维护性;灵活架构,焦点分离;<br>方便模块间组合,分解;多人协作互不干扰<br>根据commonJS规范,一个单独的文件就是一个模块,每一个模块都是一个单独的作用域,也就是在一个文件定义的变量(包括函数和类),都是私有的,对其他文件是不可见的!</li><li>Commonjs规定,每个文件的对外接口是module.exports对象.这个对象的所有;<br>2.<code>module</code>对象:在每一个模块中,<code>module</code>对象代表该模块自身,<br><code>exports</code>属性:是<code>module</code>对象的一个属性,他向外提供接口;</li></ol><p>例:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span>  add  = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">ruturn a +x ;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="built_in">module</span>.exports.x  = x;</span><br><span class="line"> <span class="built_in">module</span>.exports.add = add;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">上面代码通过<span class="built_in">module</span>.exports对象,定义了对外接口,输出变量X 和函数add, <span class="built_in">module</span>.exports对象是可以被其他文件导入,起始就是文件内部和外部通信的桥梁;</span><br><span class="line">conts  a  = <span class="built_in">require</span>(<span class="string">'./xxx.js'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a.x) <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">3</span>)) <span class="comment">//8</span></span><br></pre></td></tr></table></figure></p><h2 id="Packages-包"><a href="#Packages-包" class="headerlink" title="Packages 包"></a>Packages 包</h2><ol><li>包的目的就是基于commonJS规范实现的应用程序或类库;</li><li>包可以看做是模块,代码和其他资源组合起来的形成的独立作用域;<br><strong>规范的包结构</strong></li></ol><ol><li><code>package.json</code>必须在包的顶层目录下;</li><li><code>package.json</code>文件必须符合json格式,并且必须包含如下三个属性<br><br></li></ol><ul><li><code>name</code>:包的名字  名称必须唯一</li><li><code>version</code>:包的版本号  </li><li><code>main</code>:表示包的入口文件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- +bin   二进制文件在Bin目录下</span><br><span class="line">- +lib   Javascript 在lib目录下</span><br><span class="line">- +doc  文档在doc目录下</span><br><span class="line">- +test 单元测试在test目录</span><br><span class="line">- +<span class="string">`package.json`</span>在顶层目录下</span><br></pre></td></tr></table></figure><p><strong>包描述文件 package.json</strong></p><ul><li>name: 名称必须唯一</li><li>description:包的简要说明</li><li>version:符合语义化版本识别规范的版本字符串</li><li>keywords:关键字数据.通常用于搜索</li><li>maintainers:维护者数组.每个元素要包含name,email,web可选字段</li><li>contributors:贡献者数组,格式和maintainers相同,包的作者应该是贡献者数据的第一个元素</li><li>bugs:提交bug的地址.可以是网址或电子邮件地址</li><li>licenses:许可证数组,每个元素要包含的type和url字段;</li><li>repositories:仓库托管地址数组,每个元素要包含type,Url和path字段;</li><li>dependencies:包的依赖,一个关联数组.由包名称和版本号组成</li><li>devDepencies:开发依赖项,表示一个包在开发期间用到的依赖项</li></ul>]]></content>
    
    <summary type="html">
    
      node Commonjs
    
    </summary>
    
    
      <category term="commonJS" scheme="https://lipapasma.github.io/lipapa.github.io/tags/commonJS/"/>
    
      <category term="package.json" scheme="https://lipapasma.github.io/lipapa.github.io/tags/package-json/"/>
    
  </entry>
  
  <entry>
    <title>Node基础</title>
    <link href="https://lipapasma.github.io/lipapa.github.io/2018/07/27/node-%E5%9F%BA%E7%A1%80/"/>
    <id>https://lipapasma.github.io/lipapa.github.io/2018/07/27/node-基础/</id>
    <published>2018-07-27T06:23:33.000Z</published>
    <updated>2018-07-29T12:02:27.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>node JS 是什么 </li><li>一个js运行时环境 (不是一门语言/库/框架)</li><li>1.node.js中的Javascript没有BOM DOM 只有EcmaScript(基本语法), 因为服务器不操作页面</li><li><p>2.在Node这个JavaScript 执行环境中为js提供一些服务器级别的操作Api 文件读写 构建网络服务, 网络通信 http服务</p><p><strong>特性</strong><br>使用时间驱动,实现异步,轻量高效</p></li></ul><h2 id="Es6-常用语法"><a href="#Es6-常用语法" class="headerlink" title="Es6 常用语法"></a>Es6 常用语法</h2><p> <strong>let 与const</strong></p><p>-var 关键字 缺点 1.变量名提升 2.没有块级作用域</p><p>-let 特性 :</p><ul><li>没有变量的提升</li><li>有{} 作用域</li></ul><p>const 特性:</p><ul><li>没有变量提升的问题</li><li>const 定义的常量,无法被重新赋值</li><li>当定义常量的时候,必须定义且初始化 .否则报语法错误  定义一个默认值<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> 和<span class="keyword">const</span> 都是块级作用域</span><br><span class="line">&#123;&#125;大括号内的代码亏即为<span class="keyword">let</span> 和<span class="keyword">const</span> 的作用域</span><br><span class="line"><span class="keyword">const</span> = &#123;&#125;;</span><br><span class="line">改内存地址 不改值 不会报错;</span><br><span class="line">例:</span><br><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">name</span>:<span class="string">'cc'</span>&#125;;</span><br><span class="line">a.name =<span class="string">'cc'</span> <span class="comment">// 不会报错</span></span><br><span class="line"></span><br><span class="line">a = &#123;<span class="attr">name</span>:<span class="string">'cc'</span>&#125;  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>解构赋值</strong> <br><br>所谓解构赋值 就是把某个对象中的属性当做变量 给解放出来,以后就能够当做变量直接使用 <br><br>可以使用<code>&#39; : &#39;</code>为解构出来的变量重命名  <br><br>主要用在 数组和对象上 <br><br>实例: <br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">name :<span class="string">'解构赋值案例'</span>,</span><br><span class="line">age : <span class="number">24</span>,</span><br><span class="line">sex : <span class="string">'男'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;name,age,sex&#125; =parson</span><br><span class="line"><span class="built_in">console</span>.log(age)  <span class="comment">// 24</span></span><br></pre></td></tr></table></figure></p><p><br><br>使用解构赋值表达式时,如果指定的局部变量名称在对象中不存在,那么这个局部变量会被赋值为undefined<br><br>[注意]一定要用一对小括号包裹解构赋值的语句.js引擎将一对开放的花括号视为一个代码块,语法规定,代码块语句<br>不允许出现在赋值语句左侧,添加小括号后可以将代码块语句转化为一个表达式.从而实现整个解构赋值过程.<br>当指定的属性不存在,可随意定义一个默认值.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    type: <span class="string">"Identifier"</span>,</span><br><span class="line">    name: <span class="string">"foo"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; type, name, value = <span class="literal">true</span> &#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(type); <span class="comment">// "Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// "foo"</span></span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="解构对象结构"><a href="#解构对象结构" class="headerlink" title="解构对象结构"></a>解构对象结构</h2><ul><li>解构嵌套对象仍然与对象字面量的语法相似,可以将对象拆解以获取想要的信息<br></li><li>例:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line"> tyep:<span class="string">'foo'</span>,</span><br><span class="line">  loc:  &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">       line:<span class="number">1</span>,</span><br><span class="line">       column:<span class="number">1</span></span><br><span class="line">       &#125;,</span><br><span class="line">       end: &#123;</span><br><span class="line">       line:<span class="number">1</span>,</span><br><span class="line">       column:<span class="number">4</span></span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">let</span> &#123;<span class="attr">loc</span>:&#123;start&#125; &#125; =node;</span><br><span class="line">   consoloe.log(start.lone)   <span class="comment">//1 </span></span><br><span class="line">  consolo.log(start.column)  <span class="comment">//1</span></span><br><span class="line"><span class="comment">//更进一步,使用一个与对象属性名不同的局部变量名</span></span><br><span class="line"><span class="comment">// 提取 node.loc.start</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">loc</span>:&#123;<span class="attr">start</span>:localStart&#125;&#125; = node</span><br><span class="line"><span class="built_in">console</span>.log(localStart.line)  <span class="comment">//1</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>在日常开发中,通常会碰到需要提取数组中的某一项.并把它当在变量中这个需求.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nbaStars=[<span class="string">'yaoming'</span>,<span class="string">'kobe'</span>,<span class="string">'james'</span>,<span class="string">'paul'</span>]</span><br><span class="line"><span class="keyword">let</span> [chinaStar,...usaStar] = nbaStars</span><br><span class="line"><span class="keyword">let</span> [...myidol] = nbaStars</span><br><span class="line"><span class="built_in">console</span>.log(usaStar,chinaStar,myidol)</span><br><span class="line"><span class="comment">//output yaoming ['kobe','james','paul'] paul</span></span><br></pre></td></tr></table></figure></p><p>简单数组解构理解: <br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> [first,second] = colors</span><br><span class="line"><span class="built_in">console</span>.log(first) <span class="comment">//a</span></span><br><span class="line"><span class="built_in">console</span>.log(second) <span class="comment">//b</span></span><br></pre></td></tr></table></figure></p><p><strong>不定元素</strong></p><p>ES6的函数引入了不定参数,而在数组解构语法中有个相似的概念:不定元素;在数组中,可以通过 …语法将数组中剩余的元素赋值给一个指定的变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ firstColor, ...restColors ] = colors;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstColor);          <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(restColors.length);   <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(restColors[<span class="number">0</span>]);       <span class="comment">// "green"</span></span><br><span class="line"><span class="built_in">console</span>.log(restColors[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>通过不定元素来实现数组克隆 <br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5克隆数组</span></span><br><span class="line"> <span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="comment">//用concat() 方法 设计初衷是链接两个数组.不传参数会返回当前数组的副本</span></span><br><span class="line"><span class="keyword">var</span> clonedColors = colors.concat();</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6 通过不定元素来实现相同功能</span></span><br><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</span><br><span class="line"><span class="keyword">let</span> [ ...clonedColors ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(clonedColors);   <span class="comment">// "[red,green,blue]"</span></span><br></pre></td></tr></table></figure></p><h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><p><strong>模板字符串</strong><br>-字符串模板,用反引号 “`” 来创建字符串,此方法创建的字符串里面可以包含由$符号加花括号包裹的变量${value}<br>例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 获取当前的日期对象</span></span><br><span class="line"> <span class="keyword">const</span> dd = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"> <span class="keyword">const</span> y =dd.getFullYear()</span><br><span class="line"> <span class="keyword">const</span> m =dd.getMonth() +<span class="number">1</span>    <span class="comment">// 0- 11</span></span><br><span class="line"> <span class="keyword">const</span> d =dd.getData().toString()padStart(<span class="number">2</span>,<span class="string">'0'</span>)  <span class="comment">//向前补两位 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hh = dt.getHours()</span><br><span class="line"><span class="keyword">const</span> mm = dt.getMinutes()</span><br><span class="line"><span class="keyword">const</span> ss = dt.getSeconds().toString().padStart(<span class="number">2</span>, <span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dateStr = <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span> <span class="subst">$&#123;hh&#125;</span>:<span class="subst">$&#123;mm&#125;</span>:<span class="subst">$&#123;ss&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dateStr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'123'</span> <span class="comment">//  在前面填充 3个 0  在后面，填充 3个 o</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = str.padStart(<span class="number">6</span>, <span class="string">'0'</span>).padEnd(<span class="number">9</span>, <span class="string">'o'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**ES6新的方法** &lt;br&gt;</span></span><br><span class="line"><span class="string">startsWith() 和endsWith() &lt;br&gt;</span></span><br><span class="line"><span class="string">- startsWith()  用来判断字符串.是否以指定的字符开头,如果是则返回true  否则false&lt;br&gt;</span></span><br><span class="line"><span class="string">- endsWith()    用来判断字符串.是否以指定的字符结尾,如果是则返回true  否则false&lt;br&gt;</span></span><br><span class="line"><span class="string">- 3. padStart() 和 padEnd()&lt;br&gt;</span></span><br><span class="line"><span class="string">     padStart() 用于头部补全；&lt;br&gt;</span></span><br><span class="line"><span class="string">     padEnd() 用于尾部补全。</span></span><br><span class="line"><span class="string">## 函数扩展 ##</span></span><br><span class="line"><span class="string">一:函数参数的默认值 &lt;br&gt;</span></span><br><span class="line"><span class="string">ES6允许为函数的参数设置默认值.即直接写在参数定义的后面 &lt;br&gt;</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x,y=<span class="number">5</span></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> x + y</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(log(<span class="number">5</span>))   <span class="comment">//10</span></span><br></pre></td></tr></table></figure><p><strong>箭头函数</strong> <br><br> 特性:箭头函数内部的this 永远和箭头函数外部的this保持一致;<br> 箭头函数本质上是一个匿名函数<br> 箭头函数格式  (参数列表) =&gt; {函数体};</p><p>-变体1：如果箭头函数左侧的形参列表中 只有一个形参，那么，（）可以省略<code>（x) =&gt; { console.log(x)}</code> 直接可以改造成<br>  <code>x =&gt; { console.log(x) }</code><br><br>-变体2 如果箭头函数 左侧只有一个形参，右侧只有一个行代码，那么，左侧的（） 和右侧的{} 都可以省略   <code>(x,y) =&gt; {console.log(x+y) }</code> 可以改造成 <code>(x,y) =&gt; console.log (x+y)</code> <br><br>-变体3 如果箭头函数左侧只有一个形参 右侧只有一行代码，那么左侧的（） 和右侧的 {} 都可以省略 <code>(x) =&gt; {console.log(x)}</code><br>可改造成  <code>x =&gt;console.log(x)</code> <br><br><strong>注意！</strong> ： 如果我们省略的右侧的 {} ，那么默认就会把右侧的函数体中的代码执行结果，返回出去<code>（x,y) =&gt; { return x+y}</code> 直接可简写为 <code>（x,y) =&gt;x+y</code><br><br><strong>案例复制，读取文件</strong>  <br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入fs 文件模块  常量去接收</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入path 模块  提供了一些工具函数，用于处理文件与目录的路径</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为 Windows下默认的编码格式是ASNI，其实这并不是真正的编码格式。但Node.JS默认的编码、解码则是目前通用的UTF-8。因此在读取Windows默认的TXT文件时会显示乱码  </span></span><br><span class="line"><span class="comment">// 想要解决这个问题 可以通过转存为utf-8 格式解决  或者 安装编码解码模块</span></span><br><span class="line"><span class="keyword">const</span> iconv = <span class="built_in">require</span>(<span class="string">'iconv-lite'</span>)  <span class="comment">//编码解码模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件  path.join()  方法使用平台特定的分隔符 '\'把全部给定的path片段连接到一起，并生成规范的路径，返回string</span></span><br><span class="line"> <span class="comment">// __dirnam 当前模块的目录名称</span></span><br><span class="line">fs.readFile(path.jion(__dirnam,<span class="string">"基于js文件目录+文件名"</span>),(err,data) =&gt; &#123;</span><br><span class="line">    <span class="comment">//如果err 返回对象 则读取不到文件   </span></span><br><span class="line"> <span class="keyword">if</span>(err)   <span class="built_in">console</span>.log(<span class="string">"读取错误"</span>+err.message)</span><br><span class="line"><span class="comment">// 定义一个let 存储 data 这个对象  data 类型是object  并且用iconv 解码模块 转为gbk格式解决乱码</span></span><br><span class="line"><span class="keyword">let</span> datas =iconv.decode(data,<span class="string">'gbk'</span>)</span><br><span class="line"><span class="comment">//用空格分隔txt文件的字符串 </span></span><br><span class="line"><span class="keyword">let</span> str =datas.split(<span class="string">""</span>)</span><br><span class="line"><span class="comment">// 创建一个空的对象接收</span></span><br><span class="line"><span class="keyword">let</span> strs = <span class="string">" "</span> ;</span><br><span class="line">str.forEach( <span class="function">(<span class="params">item,index</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">if</span>(item.length !=<span class="number">0</span>) &#123;</span><br><span class="line">     strs += item.split(<span class="string">"="</span>).jion(<span class="string">":"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"> &#125;)</span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line"> fs.writeFile(path.jion(__dirnam,<span class="string">"基于js文件目录+自定义新创建的文件名"</span>),str.trim(),(err,data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)  <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'写入失败'</span>+err.message) </span><br><span class="line">   consloe.log(<span class="string">'写入成功'</span>)</span><br><span class="line">  &#125;）</span><br><span class="line"> &#125;）</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      node入门
    
    </summary>
    
    
      <category term="-node" scheme="https://lipapasma.github.io/lipapa.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>Dom 对象</title>
    <link href="https://lipapasma.github.io/lipapa.github.io/2018/07/27/Dom-%E5%AF%B9%E8%B1%A1/"/>
    <id>https://lipapasma.github.io/lipapa.github.io/2018/07/27/Dom-对象/</id>
    <published>2018-07-27T00:38:49.000Z</published>
    <updated>2018-07-27T12:05:10.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dom-对象关系"><a href="#Dom-对象关系" class="headerlink" title="Dom 对象关系:"></a>Dom 对象关系:</h2><p>  <img src="https://images2018.cnblogs.com/blog/1364550/201807/1364550-20180726192702227-1138070441.png" alt="dom结构"></p><h2 id="节点自身属性"><a href="#节点自身属性" class="headerlink" title="节点自身属性"></a>节点自身属性</h2><p>  -attributes  —&gt;  节点(元素)的属性节点<br>  -nodeType    —&gt;  节点类型<br>  -nodeValue   —&gt;  节点值<br>  -innerHTML   —&gt;  节点</p><h2 id="导航属性"><a href="#导航属性" class="headerlink" title="导航属性"></a>导航属性</h2><p>  -parentNOde  —&gt; 节点元素的父节点<br>  -firstChild  —&gt; 节点下第一个子元素<br>  -lastChild   —&gt; 节点下最后一个子元素<br>  -childNodes  —&gt; 节点元素的子节点<br>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello yuan<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"> </span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> div=<span class="built_in">document</span>.getElementById(<span class="string">"div2"</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(div.nextSibling.nodeName);  <span class="comment">//思考:为什么不是P?</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="节点数中的节点彼此拥有的层级关系"><a href="#节点数中的节点彼此拥有的层级关系" class="headerlink" title="节点数中的节点彼此拥有的层级关系"></a>节点数中的节点彼此拥有的层级关系</h2><p>  -父(parent),子(child)和同胞(sibling)等术语用于扫描这些关系.父节点用于子节点,同级的子节点被称为同胞(兄弟)<br>  -在节点数中,顶端节点被称为根(root)<br>  -每个节点都有父节点,除了根(他没有父节点)<br>  -一个节点可拥有任意数量的子<br>  -同胞是拥有相同父节点的节点<br>  <img src="http://images2015.cnblogs.com/blog/1020990/201707/1020990-20170724202913606-469266009.png" alt="节点图"><br>  页面查找:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">通过 getElementById() 方法</span><br><span class="line">通过 getElementsByTagName() 方法</span><br><span class="line">通过使用 getElementsByClassName() 方法 </span><br><span class="line">通过使用 getElementsByName() 方法</span><br></pre></td></tr></table></figure></p><hr><p>onload:<br>这个属性的触发 标志着页面内容被加载完成.<br>应用场景:当有些事情我们希望页面加载完立刻执行,可以使用该事件属性<br>onsubmit:<br>当表单在提交时触发.该属性也只能给form元素使用.<br>应用场景:在表单提交前验证用户输入是否正确.如果验证失败,在该方法中我们应该阻止表单的提交.<br>Event 对象<br>代表事件的状态,比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。</p><p>事件通常与函数结合使用，函数不会在事件发生前被执行！event对象在事件发生时系统已经创建好了,并且会在事件函数被调用时传给事件函数.我们获得仅仅需要接收一下即可.</p><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**增加**</span><br><span class="line">createElement(name) 创建元素</span><br><span class="line">appendChild()  将元素追加</span><br><span class="line">**删除**</span><br><span class="line"><span class="number">1</span> 获得要删除的元素</span><br><span class="line"><span class="number">2</span> 获得他的父元素</span><br><span class="line"><span class="number">3</span> 使用removeChild () 方法删除</span><br></pre></td></tr></table></figure><p><strong>改</strong></p><p>1 使用上面的增和删结合完成修改<br>2  第二种  使用 setAttribute() 方法修改属性<br>使用innerHTML 属性修改元素内容</p>]]></content>
    
    <summary type="html">
    
      整理
    
    </summary>
    
      <category term="Dom" scheme="https://lipapasma.github.io/lipapa.github.io/categories/Dom/"/>
    
    
      <category term="JS  Dom" scheme="https://lipapasma.github.io/lipapa.github.io/tags/JS-Dom/"/>
    
  </entry>
  
  <entry>
    <title>Js 基础</title>
    <link href="https://lipapasma.github.io/lipapa.github.io/2018/07/24/JS%E5%9F%BA%E7%A1%80/"/>
    <id>https://lipapasma.github.io/lipapa.github.io/2018/07/24/JS基础/</id>
    <published>2018-07-24T12:53:16.623Z</published>
    <updated>2018-07-27T06:21:53.893Z</updated>
    
    <content type="html"><![CDATA[<p>-核心(ECMAScript)<br>-文档对象模型 (DOM) Document object model(整合js,css,html)<br>-浏览器对象模型(BOM) Broswer object model (整合JS和浏览器)</p><p><img src="https://0214-1256944971.cos.ap-shanghai.myqcloud.com/images/JS%E7%BB%93%E6%9E%84.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDhLrlmsZu2BS9qbuH7T02mvHrM4ZLQXZi%26q-sign-time%3D1532444966%3B1532446766%26q-key-time%3D1532444966%3B1532446766%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D7874cfec1b29823637aee0d50adacdd11523883d&amp;token=bba318659135e08ad4024f97bfa112a80f1e680710001&amp;clientIP=114.221.99.55&amp;clientUA=316099ea-2517-40f5-9a33-9a0a1b0edea7" alt="JS基础图"><br>-简单的数.ECMAScript 描述以下内容:</p><pre><code>- 语法 类型 语句 关键字 保留字 运算符 对象   [      - 1 封装       - 2 继承      - 3 多态]</code></pre><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>  <img src="https://0214-1256944971.cos.ap-shanghai.myqcloud.com/images/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9B%BE.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKID6c6VyswU1JilakyJMNCK4e0SC5RlvdHy%26q-sign-time%3D1532444758%3B1532446558%26q-key-time%3D1532444758%3B1532446558%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Df75b88d3eea788d267aed321a65452b10f912a0b&amp;token=5d950fedc44b7910a6e89ec42ec1f6330ff0fb5910001&amp;clientIP=114.221.99.55&amp;clientUA=29940c93-d655-47f6-b58a-1b68d834834c" alt="数据类型图"></p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ul><li>Numeber —&gt; 数字类型 包括整型  浮点型  (整数和小数)<pre><code>- String  ---&gt; 字符串- Boolean ---&gt; 布尔型 ,ture/false- Undefined类型 --&gt; 该类型只有一个值,即undefined,当声明的变量未初始化时,该变量的默认值是undefined,当函数无明确返回值是,返回的也是undefined.- Null  ---&gt; 只有一个专用值 null ,用于表示尚未存在的对象,如果函数或者方法要返回的是对象,那么找不到该对象时,返回的通常是null.</code></pre></li><li>引用数据类型 (复杂数据类型)    <pre><code>- 函数- 对象 - 数组</code></pre></li><li><p>类型查询函数 typeof  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span>(<span class="string">'test'</span>+<span class="number">3</span>)   &lt;!--  <span class="string">"string"</span>  --&gt;</span><br><span class="line"><span class="keyword">typeof</span>(<span class="literal">null</span>)       &lt;!--  <span class="string">"object"</span>  --&gt;</span><br><span class="line"><span class="keyword">typeof</span>(<span class="literal">true</span>+<span class="number">1</span>)     &lt;!--  <span class="string">"number"</span>  --&gt;</span><br><span class="line"><span class="keyword">typeof</span>(<span class="literal">true</span>-<span class="literal">false</span>) &lt;!--  <span class="string">"number"</span>  --&gt;</span><br></pre></td></tr></table></figure><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2></li></ul>]]></content>
    
    <summary type="html">
    
      知识要点
    
    </summary>
    
      <category term="web" scheme="https://lipapasma.github.io/lipapa.github.io/categories/web/"/>
    
      <category term="JS基础" scheme="https://lipapasma.github.io/lipapa.github.io/categories/web/JS%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="web" scheme="https://lipapasma.github.io/lipapa.github.io/tags/web/"/>
    
      <category term="JS" scheme="https://lipapasma.github.io/lipapa.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>原型是什么</title>
    <link href="https://lipapasma.github.io/lipapa.github.io/2018/07/24/my-first-blog/"/>
    <id>https://lipapasma.github.io/lipapa.github.io/2018/07/24/my-first-blog/</id>
    <published>2018-07-24T00:44:32.346Z</published>
    <updated>2018-07-25T04:50:40.045Z</updated>
    
    <content type="html"><![CDATA[<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=25706282&auto=0&height=66"><br></iframe><br>在JavaScript中原型是一个prototype对象，用于表示类型之间的关系。<br> 原型链是针对构造函数的，比如我先创建了一个函数，然后通过一个变量new了这个函数，那么这个被new出来的函数就会继承创建出来的那个函数的属性，然后如果我访问new出来的这个函数的某个属性，但是我并没有在这个new出来的函数中定义这个变量，那么它就会往上（向创建出它的函数中）查找，这个查找的过程就叫做原型链。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> ==&gt; 构造函数<span class="number">1</span> ==&gt; 构造函数<span class="number">2</span></span><br><span class="line">&lt;span style=<span class="string">"font-size:14px;"</span>&gt;varPerson=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.age=<span class="string">"匿名"</span>&#125;;</span><br><span class="line">varStudent=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="comment">//创建继承关系,prototype执行Person的一个实例对象</span></span><br><span class="line">Student.prototype=<span class="keyword">new</span>  Person();<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>原型API关系图<br><img src="http://images2015.cnblogs.com/blog/341820/201606/341820-20160610194715371-759828586.png" alt="原型图"><br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1532438261291&amp;di=e8d0c0383aea37427b26691f124b1240&amp;imgtype=0&amp;src=http%3A%2F%2Fpic2.zhimg.com%2Fv2-7208c58973fa469891e6be970df3ff54_b.jpg" alt="原型图"><br><img src="https://www.newasp.net/attachment/article/2013-3/20133513150105.jpg" alt="原型继承"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__); <span class="comment">//A &#123;&#125;（即构造器function A 的原型对象）</span></span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__.__proto__); <span class="comment">//Object &#123;&#125;（即构造器function Object 的原型对象）</span></span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__.__proto__.__proto__); <span class="comment">//null</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      在JavaScript中原型是一个prototype对象，用于表示类型之间的关系.
    
    </summary>
    
      <category term="JS高级" scheme="https://lipapasma.github.io/lipapa.github.io/categories/JS%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="概念" scheme="https://lipapasma.github.io/lipapa.github.io/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://lipapasma.github.io/lipapa.github.io/2018/07/23/hello-world/"/>
    <id>https://lipapasma.github.io/lipapa.github.io/2018/07/23/hello-world/</id>
    <published>2018-07-23T05:49:18.842Z</published>
    <updated>2018-07-27T12:05:25.205Z</updated>
    
    <content type="html"><![CDATA[<ul><li>安装完成后<br> 在命令行输入:</li></ul><ol><li><code>$git config --global user.name</code> “自定用户名”</li><li><code>t-config --gbobal user.email</code> “自定义邮箱”</li><li>每个机器都需要必须自报家门: 你的名字 和你的Email</li><li>git config 命令的 –global  用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</li></ol><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>###1. 第一步</p><p>   <code>$ mkdir learngit</code><br>    <code>$ cd learngit</code><br>    <code>$ pwd</code><br>    pwd命令用于显示当前目录   代码仓库位于/user/michael/learngit</p><p>###2.第二步<br>初始化一个Git仓库，使用git init命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git init </span><br><span class="line"></span><br><span class="line">Initalized emty Git repository in/user/michael/learngit/.git/</span><br></pre></td></tr></table></figure></p><p>瞬间git 就把仓库建好了,而且告诉你是一个空仓库<br>如果你没看到.git目录 是因为这个目录是默认隐藏, 用ls –ah 命令可以看见</p><p>###第三步，用命令git add告诉Git，把文件添加到仓库：<br>-先创建<br><code>$ touch readme.txt</code><br>-再 add  (将工作区文件提交到暂存区stage)<br><code>$ git add readme.txt</code><br>使用命令git add <file>，注意，可反复多次使用，添加多个文件；</file></p><p>-提交文件<br><code>$ git commit -m &quot;提交的备注信息 便于查找&quot;</code><br>使用命令git commit -m <message>，完成。</message></p><p>###第四步<br>-查看状态<br><code>$git status</code>  </p><p>-查看提交历史<br><code>$git log</code></p><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>-首先查看提交历史  复制版本号<br>-再输入以下命令<br><code>git reset --hard 版本号</code></p>]]></content>
    
    <summary type="html">
    
      知识要点
    
    </summary>
    
      <category term="git" scheme="https://lipapasma.github.io/lipapa.github.io/categories/git/"/>
    
      <category term="node" scheme="https://lipapasma.github.io/lipapa.github.io/categories/git/node/"/>
    
    
      <category term="Git" scheme="https://lipapasma.github.io/lipapa.github.io/tags/Git/"/>
    
      <category term="node" scheme="https://lipapasma.github.io/lipapa.github.io/tags/node/"/>
    
  </entry>
  
</feed>
